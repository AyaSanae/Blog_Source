---
title: 指针的常用用法
date: 2022-11-17 20:23:27
tags: C/C++
catagories: 编程语言
excerpt: "指针的操作简单,那具体要怎么用呢?"
---

# 0xFE 指针基础

## 0x01 计算机存储机制
虽然学的时候可能已经学过了,但多少还是写点.
假如我们有
```c
int a = 0x1024EF;
char b[] = {0xEF,0x24,0x10};
```
0x6950开始的这段是a存储在内存中的数据，int占四个字节，所以占用了0x6950~0x6953的空间

从EF低位开始存储称之为小端存储

0x7950开始的这段是b数组存储在内存中的数据,char占1个字节,又因为数组是连续存储,所以0x7950~0x7952是b数组的存储位置.

|  地址   | 内存  |
|  :----:  | :----:  |
| ...  | ... |
| ...  | ... |
| 0x6950 | EF |                 
| 0x6951 | 24 |
| 0x6952 | 10 |
| 0x6953 | 00 |
| ... | ... |
| ... | ... |
| 0x7950 | EF |                 
| 0x7951 | 24 |
| 0x7952 | 10 |
| ... | ... |
| ... | ... |

我们可以看到每个字节的内存空间都对应着一段地址,相当于门牌号
***指针本身是一个变量,但是它一般存储着其他变量或数组,函数的地址***.所以我们可以用指针操作数据的地址，实现数据的间接访问.

#### 直接访问不香???

## 0x02 指针定义
定义:
```c
int *p,a;   //只有p是指针
int* b,c;   //a,b都是指针
int* d = 0; //等价于int* d = NULL; 是空指针
```
用完了的指针不用,一般会给NULL,防止乱指.
比如说
```c
int ptr_p;
for(int p=1;...){
    ...
    ptr_p=&p
    ...
}
```
p变量在for循环结束后会被销毁,但是我们ptr_p还指向了p的地址,如果后续再有变量被分到了这个地址,操作指针时就会改变这个新变量.

同级指针之间才能相互赋值，跨级赋值将会导致编译器报错或警告

无论是什么类型的指针，其本身占用的大小与操作系统的位数有关
比如64位系统指针占用8字节,32位占用4字节,16位占用2字节

#### 为什么?

我们知道一个字节是8位,一位能表达2个数值,0 或 1也就是2^1.
那么8字节能表示2^64个数值
用64位操作系统举例:
64位cpu的寻址范围是2^64位也就是说可以有2^64个地址,那我们要用一个指针,存2^64内的任一地址,那么我们指针占用的空间就要大于等于64位
也就是8个字节.而64位系统指针占用的空间就是8字节.

## 0x03 指针基本操作
```c
int p =1,b;
int* ptr_p;

ptr_p=&p;   //'&p'取p地址
b = *ptr_p; //'*p'取p内容
ptr_p++     //指针向下移动一个数据宽度
ptr_p--     //指针向上移动一个数据宽度

```

## 0x04 数组与指针
事实上数组是指针的一种表达形式.
比如我们有:
```c
char p[20]={0x23,0x98};

printf("%x,%x",p[0],p[1]);
```
等效于
```c
char* p = malloc(20);   //定义指针并申请内存
*p = 0x23;              //初始化数组
*(p+1) = 0x98; 

//printf("%x,%x",p[0],p[1]); 此种方法也可以输出,p[0]等效于*p
printf("%x,%x",*p,*(p+1));
```

数名是一个指向数组首地址的指针,这里后面会用更清晰的运用,此处暂不细说.
我们来看*(p+1),p+1是指针向下移动一个数据宽度,移动后会指向下一个值的地址然后我们用*号取出.

|指针|  地址   | 内存  |
|  :----:  |  :----:  | :----:  |
| ...  | ... |
| ...  | ... |
|p-->| 0x6950 | 23 |
|(p+1)-->| 0x6951 | 98 |      
| ...  | ... |
| ...  | ... | 

P.S. char型的数据宽度是一个字节.

# 0xFF 指针应用
## 0x10 传参
### 0x11 使用指针传递大容量的参数
我们先来看下一般的传参过程
如果我们有void test(int a[]);
那么当我们传入a[]时,程序会在内存中开辟一个新的空间,把a[]的数据复制一份放到这个新的空间中,称为值传递,就像:
![数据复制](/assets/pointer/1.jpg)
这样做的好处是能隔离数据,比如说
```c
int a[]={1,2,3,4};
test(a);
```
这样子无论test怎么操作a都不会对函数外的a数组造成任何改变,因为函数内的a[]的是独立的一块内存

而这恰好又是缺点,因为要开辟一段新的内存空间而且还有进行数据复制,这就造成了内存和算力消耗.

如果数据量小还好,数据量一大,函数外的数组占的空间本来就大,传参又开辟一块空间,而且要数据复制.
这样子看来直接访问好像不那么香了.

如果我们用指针呢?
```c
void test(int *a);
```
传参时,函数只会开辟一块内存用来放指针,指针存着a[]的地址,这样函数访问a[]时,
将会顺着指针里的地址,找到函数外的a[],直接操作a数值这样子就避免了数据复制,称为指针传递,能节省很多内存空间和算力就像:
![指针参数](/assets/pointer/2.jpg)

但是呢,这也是缺点,函数对a[]的修改会直接影响到函数外的a[]没有达到隔离的效果,但是还是有解决方法
```c
void test(const int* a);
```
这样定义成常量的话test就无法更改a数组的值

### 其实这种指针用法非常常见,接下来例举几个常见函数
```c
char *strcpy(char* dest, const char *src);  //字符串拷贝
int strcmp(const char *s1,const char *s2);  //字符串比较
size_t strlen(const char *string);          //字符串长度计算

```

这些都用到了指针作为参数,**避免了数据复制节省了空间大大提升了速度,加入const还能保证安全性**

## 0x12 指针传递输出参数
前面有提到如果用指针传参不加const的话,会导致函数可能修改函数外传入的值.
我们可以利用这个特性,达到用指针来传递输出参数
我们知道一个函数有一个返回值,但是我们用指针可以达到多个输出参数的效果如:
```c
/**********************
功能:找到int型数组中的最大值并计数
参数:
    const int* Data:目标数组首地址
    int *Max:用于存放最大值的地址
    int *MaxNum:用于存放最大值个数的地址
    int count:搜索宽度
***********************/
void FindMax(const int* Data,int *Max,int *MaxNum,int count){
    *(Max) = Data[0];
    *(MaxNum) = 1;
    
    for(int i = 1; i <=count; i++){
        if(*(Max) < Data[i])
            *(Max) = Data[i];
            else if(*(Max) == Data[i])
                (*MaxNum)++; 
    }
}
int main()
{
    int Data[]={8,9,10,10,9,8};
    int Max,MaxNum;
    
    FindMax(Data,&Max,&MaxNum,6);
    
    printf("%d,%d",Max,MaxNum);
    
    
    return(0);
}
```
从上面的FindMax()可以看出这个函数有两个输出参数Max,MaxNum,就是因为函数通过指针对函数外的变量进行修改而达成的

## 0x20传递返回值
分装函数时常常会用到指针来返回句柄,用指针将模块内的公有部分返回,让主函数持有模块的“句柄”(相当于现实中的"把手")
便于程序对指定对象的操作.
比如说
```c
/************************
这是一个分装的模块里的一部分(假设)
************************/
int Time[]={19,00,00};

int* GetTime(){
    return Time;
}
/*-------------------*/

int main(){
    int *p = GetTime(); //获取句柄

    //这样便可以对模块里的Time进行操作
}


```
如果我们不用句柄的方式来访问模块里的数据,将模块里的数据放出模块外来访问的话,很明显
这不利于分装,所以分装模块时常常会采取指针来传递返回值.

<!--
## 0x30 直接访问物理地址下的数据
### 0x31 访问硬件指定内存下的数据，如设备ID
这里用51单片机举例
-->

### 0x32 将复杂格式的数据转换为字节，方便通信与存储
如果我们有一个float型变量a=12.345,我们想把它作为信息发送出去,我们可以利用指针特性来完成这件事.

浮点型的数据存储方式比较特殊,这里且不展开讨论.
我们知道float占4个字节内存空间,看起来是这样的:
![float存储](/assets/pointer/3.jpg)

我们知道,char型变量占一个字节,char型指针能指向一个字节的空间,那么我们用char型指针指向a的地址,
再以数组的方式用循环遍历一次就可以实现数一字节一字节的发送了.我们用char数组接收,最后用一个float指针指向char数组的首地址.相当于是将数据先拆成好几份,送到目的地再重组,如图:
![指针发送数据](/assets/pointer/4.jpg)
然后用*d就可以将c[]里的数据解码成float型了，相当于读取了c[]前四字节.
代码简易实现:
```c
#include <stdio.h>

char ReciveData[20];        //用于接收数据的数组

//发送模块
void SendData(const char *data,int count){
    for(int i = 0; i< count; i++){      
        ReciveData[i] = data[i];       //发到ReciveData
    }

}

int main(){
    float a=12.345;
    char *p=(char *)&a; //char型指针指向a的地址

    SendData(p,4);  //a数据将被拆成4份(因为float占四字节,char指针一次能指向一字节)发往ReciveData[],一个一个字节的发

    float *d = (float*)ReciveData;     //解码

    printf("a=%f     *d=%f",a,*d);

    return 0;
}
```
输出结果:
```
a=12.345000     *d=12.345000
```

之所以用char * 来当指针是因为内存最小单位是字节,而char *恰好能指向一个字节的空间,相当于单位操作,更灵活;